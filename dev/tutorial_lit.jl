# # PYTHIA8.jl Tutorial
# This turorial demostrates a simple application of PYTHIA8.jl to generate some
# events and present the results in form of histograms. Plase refer to the PYTHIA 
# [documentation](https://pythia.org/manuals/pythia8312/Welcome.html) for more details 
# on the parameters and the physics processes.
#
#md # !!! note "Note that"
#md #     You can also download this tutorial as a
#md #     [Jupyter notebook](pythia8_tutorial.ipynb) and a plain
#md #     [Julia source file](pythia8_tutorial.jl).
#
#md # #### Table of contents
#md # ```@contents
#md # Pages = ["tutorial.md"]
#md # Depth = 2:3
#md # ```
#
# ## Generate events and plot the charged multiplicity distribution
# In this example, we will generate 200 events at a center of mass energy of 8000 GeV
# and plot the charged multiplicity distribution.
#
# ### Loading the necessary modules
# - We will use the `PYTHIA8` module to run the event generation.
# - We will use the [`FHist`](https://moelf.github.io/FHist.jl/stable/) module to create the histograms.
# - We will use the [`Plots`](https://docs.juliaplots.org/stable/) module to plot them.
# If these modules are not installed, you can install them by running the following commands:
# ```julia
# using Pkg
# Pkg.add("PYTHIA8")
# Pkg.add("FHist")
# Pkg.add("Plots")
# ```
using PYTHIA8
using FHist
using Plots: plot, plot!, theme
#md import DisplayAs: PNG #hide

# Define the theme for the plots. See available [themes](https://docs.juliaplots.org/stable/generated/plotthemes/) 
# and [attributes](https://docs.juliaplots.org/stable/attributes/) in Plots.jl.
theme(:wong2, frame=:box, grid=false, minorticks=true,
      guidefontvalign=:top, guidefonthalign=:right,
      xlims=(:auto, :auto), lw=1.2, lab="", colorbar=false)

# ### Initialize PYTHIA
# We will initialize PYTHIA with the following settings:
# - Center of mass energy of the collision: 8000 GeV
# - All hard QCD processes are enabled
# - Minimum transverse momentum of the hard process: 20 GeV
# 
# We use the operator `<<` to set the parameters and the operator `|>` to pipe to 
# the init function.
# This added interface is quite ergonomic, alternatively, we can use the functions directly 
# provided by C++ interface, e.g.,
# - `readString(pythia, "Beams:eCM = 8000.")` or 
# - `parm( settings(pythia), "Beams:eCM", 8000.)`
pythia = PYTHIA8.Pythia("", false);
pythia << "Beams:eCM = 8000." << 
          "HardQCD:all = on" << 
          "PhaseSpace:pTHatMin = 20.";
# The next two lines are to reduce the ouput of the event generation
pythia << "Next:numberShowEvent = 0" <<
          "Next:numberShowProcess = 0"; 
# Initialize the event generation
pythia |> init;

# ### Create a histogram
mult = Hist1D(binedges=range(-0.5, 499.5, 26));

# ### Generate events
for iEvent in 1:200
    pythia |> next || continue
    ## Find number of all final charged particles and fill histogram.
    nCharged = count(p -> isFinal(p) && isCharged(p), pythia |> event) 
    atomic_push!(mult, nCharged)
end

# ### Print the statistics and plot charged multiplicity distribution

# Print the statistics using the `stat` function from PYTHIA8.jl
pythia |> PYTHIA8.stat

# Plot the histogram
img = plot(mult, xlabel="counts", ylabel="#particles", 
           title="Charged Multiplicity Distribution", seriestype=:stepbins,
           c=2, lc=1, fill=0);
display(img)
#md PNG(img) #hide

# ## Multi-threaded version of the same example
# We repeat the same example but using multi-threading to generate the events faster.

# ### Initialize Paralel PYTHIA
pythia_mt = PYTHIA8.PythiaParallel("", false);

# PythiaParallel reads settings the same way as the normal Pythia does.
# The settings will be copied for each Pythia instance.
pythia_mt << "Beams:eCM = 8000." << 
             "HardQCD:all = on" << 
             "PhaseSpace:pTHatMin = 20.";

# The maximum degree of parallelism. If set to 0 (default), the program
# will use the maximum number of threads supported by the hardware.
pythia_mt << "Parallelism:numThreads = 4";

# This defines the number of events generated by PythiaParallel::run.
pythia_mt << "Main:numberOfEvents = 200";

# This will create and initialize each underlying Pythia instance.
function w_init(pythiaNow)::CxxBool
    Core.println("Initializing Pythia with index $(mode(pythiaNow |> settings, "Parallelism:index")).")
    return pythiaNow |> init
end;

# Initialize the event generation
init(pythia_mt, w_init);

# ### Create a histogram
mult_mt = Hist1D(binedges=range(-0.5, 499.5, 26));

# ### Generate events
# Define the user funtion that will be called for each generated event. 
# The function takes a `Pythia` object as the first argument and returns `Nothing`.
function analyze(pythiaNow)::Nothing
    nCharged = count(p -> isFinal(p) && isCharged(p), pythiaNow |> event)
    atomic_push!(mult_mt, nCharged)
    return
end
# Run the event generation
PYTHIA8.run(pythia_mt, analyze)

# ### Print the statistics and plot charged multiplicity distribution
# Print the statistics using the `stat` function from PYTHIA8.jl
pythia_mt |> PYTHIA8.stat

# Plot the resulted histogram
img = plot(mult_mt, xlabel="counts", ylabel="#particles", 
           title="Charged Multiplicity Distribution (multi-threaded)", seriestype=:stepbins,
           c=2, lc=1, fill=0);
display(img)
#md PNG(img) #hide

# ## Do some speed comparison between the two versions
# We will generate 10000 events and compare the time taken by the two versions.

empty!(mult);
empty!(mult_mt);

# ### Single-threaded version
st_elap = @elapsed begin
    for iEvent in 1:1000
        pythia |> next || continue
        nCharged = count(p -> isFinal(p) && isCharged(p), pythia |> event) 
        atomic_push!(mult, nCharged)
    end
end
# ### Multi-threaded version
pythia_mt << "Main:numberOfEvents = 1000"
mt_elap = @elapsed begin
    PYTHIA8.run(pythia_mt, analyze)
end

# Print the speedup factor (4 threads)
println("Speedup is $(st_elap/mt_elap).")

# ### Make a plot of the speedup factor
n_threads = [2^n for n in 0:5]
speedup = Float64[]
w_init(pythiaNow)::CxxBool = pythiaNow |> init
for n_thread in n_threads
    empty!(mult_mt)
    _pythia = PYTHIA8.PythiaParallel("", false);
    _pythia << "Beams:eCM = 8000." <<
               "HardQCD:all = on" <<
               "PhaseSpace:pTHatMin = 20." <<
               "Parallelism:numThreads = $n_thread" <<
               "Main:numberOfEvents = 1000"
    init(_pythia, w_init)

    elap = @elapsed begin
        PYTHIA8.run(_pythia, analyze)
    end
    push!(speedup, st_elap/elap)
end;
# Plot the speedup factor
img = plot(n_threads, speedup, xlabel="#threads", ylabel="speedup",
           title="Speedup vs #threads (#cores = $(Sys.CPU_THREADS))", 
           seriestype=:scatter, legend=false,
           xscale=:log10, yscale=:log10);
           # Add a line to the same plot
plot!(n_threads, n_threads, seriestype=:line)
display(img)
#md PNG(img) #hide

#md # !!! note "Note that"
#md #     The plot is generted in the CI node using its 
#md #     processing cores and may not scale as expected.


