var documenterSearchIndex = {"docs":
[{"location":"release_notes/#Release-Notes","page":"Release Notes","title":"Release Notes","text":"","category":"section"},{"location":"release_notes/#0.2.3-(22-01-2026)","page":"Release Notes","title":"0.2.3 (22-01-2026)","text":"","category":"section"},{"location":"release_notes/#Fixes","page":"Release Notes","title":"Fixes","text":"Fails on Julia 1.12.4 #10\nPackage does not work on Windows #9\nMethod of -(this::Ptr{Nothing}, f::Int64) necessary for PYTHIA8? #7","category":"section"},{"location":"release_notes/#0.2.2-(29-08-2025)","page":"Release Notes","title":"0.2.2 (29-08-2025)","text":"","category":"section"},{"location":"release_notes/#New-functionality","page":"Release Notes","title":"New functionality","text":"Upgraded to latest CxxWrap version 0.17.3","category":"section"},{"location":"release_notes/#0.2.1-(18-11-2024)","page":"Release Notes","title":"0.2.1 (18-11-2024)","text":"","category":"section"},{"location":"release_notes/#New-functionality-2","page":"Release Notes","title":"New functionality","text":"Adapted gen/build.jl to use the WrapIt.jl package instead of a locally installed wrapit ","category":"section"},{"location":"release_notes/#Fixes-2","page":"Release Notes","title":"Fixes","text":"Removed Hist::operator+(double) to avoid #457\nDo not export cd to avoid warnings  ","category":"section"},{"location":"release_notes/#0.2.0-(07-11-2024)","page":"Release Notes","title":"0.2.0 (07-11-2024)","text":"","category":"section"},{"location":"release_notes/#New-functionality-3","page":"Release Notes","title":"New functionality","text":"Added 2 more new examples: main294.jl and main296.jl\nAdded a tutorial in the documentation using the module Literate.jl to generate markdown and notebook from single source.","category":"section"},{"location":"release_notes/#0.1.1-(03-10-2024)","page":"Release Notes","title":"0.1.1 (03-10-2024)","text":"","category":"section"},{"location":"release_notes/#Fixes-3","page":"Release Notes","title":"Fixes","text":"Lower the version requirements InteractiveUtils.","category":"section"},{"location":"release_notes/#0.1.0-(25-09-2024)","page":"Release Notes","title":"0.1.0 (25-09-2024)","text":"Initial release with basic functionality needed to run the first 3 examples.","category":"section"},{"location":"api/#Public-Documentation","page":"Public APIs","title":"Public Documentation","text":"Documentation for PYTHIA8.jl public interface.\n\n","category":"section"},{"location":"api/#Index","page":"Public APIs","title":"Index","text":"Pages   = [\"api.md\"]\nModules = [PYTHIA8]\nOrder   = [:type]\n\nPages   = [\"api.md\"]\nModules = [PYTHIA8, Base]\nOrder   = [:function]\n\n","category":"section"},{"location":"api/#Types","page":"Public APIs","title":"Types","text":"This is the list of all types and functions defined for PYTHIA8","category":"section"},{"location":"api/#Functions","page":"Public APIs","title":"Functions","text":"","category":"section"},{"location":"api/#PYTHIA8.__init__-Tuple{Pythia8!UserHooks}","page":"Public APIs","title":"PYTHIA8.__init__","text":"__init__(self::UserHooks)\n\nThis function initializes the UserHooks object by creating an instance of Pythia8UserHooks  and setting the hooks for each method defined by the user.\n\n\n\n\n\n","category":"method"},{"location":"#Julia-bindings-for-PYTHIA","page":"Introduction","title":"Julia bindings for PYTHIA","text":"","category":"section"},{"location":"#Description","page":"Introduction","title":"Description","text":"Julia bindings for the PYTHIA package used for generating high-energy physics collision events. It facilitates the interface with the PYTHIA client library, by writing Julia code instead of having to write C++ code. This package is developed using the CxxWrap.jl package to wrap C++ types and functions to Julia. Wrapper C++ code is generated with the help of WrapIt tool that uses of the clang library.\n\nThe Julia interface has been inspired by the functionality provided by Pythia Python interface.","category":"section"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"The PYTHIA8.jl package does no require any special installation. Stable releases are registered into the Julia general registry, and therefore can be deployed with the standard Pkg Julia package manager. This would bring automatically an installation of PYTHIA binary libraries as artifacts corresponding to the current platform (the so called _jll packages). Linux and MacOS operating systems with x86_64, powerpc64le and aarch64 architectures are supported. \n\njulia> using Pkg\njulia> Pkg.add(\"PYTHIA8\")","category":"section"},{"location":"#Interface","page":"Introduction","title":"Interface","text":"Only the classes that provide the everyday functionality of PYTHIA have been wrapped. Additional classes and functionality can be included upon request. This is a summary of the currently provided classes:\n\ntop level: Pythia, PythiaParallel\nevent access: Event, Particle, Vec4\nsettings and information: HIInfo, Settings, Flag, Mode, Parm, Word, FVec, MVec, PVec, WVec\nuser interface pointers: Rndm, PDF, DecayHandler, RndmEngine, UserHooks, MergingHooks, BeamShape, SigmaProcess, TimeShower, SpaceShower, HeavyIons\nanalysis tools: Hist, HistPlot, SlowJet\nkinematic functions: m, m2, dot3, cross3, cross4, theta, costheta, phi, cosphi, RRapPhi, REtaPhi","category":"section"},{"location":"#Limitations","page":"Introduction","title":"Limitations","text":"Methods returning or accepting as argument a std::map have not been wrapped since this is a current limitation of the CxxWrap package.","category":"section"},{"location":"#Getting-Started","page":"Introduction","title":"Getting Started","text":"Have a look at the following trivial interactive session:\n\njulia> using PYTHIA8\n\njulia> pythia = PYTHIA8.Pythia(\"\", false)\nPYTHIA8.Pythia8!PythiaAllocated(Ptr{Nothing} @0x00000001200d0000)\n\njulia> csets = pythia |> settings # which equivalent to csets = settings(pythia)\nCxxRef{Pythia8!Settings}(Ptr{Pythia8!Settings} @0x00000001200d02d0)\n\njulia> list(csets, \"Init:\")\n *-------  PYTHIA Flag + Mode + Parm + Word + FVec + MVec + PVec + WVec Settings (with requested string) ----------* \n |                                                                                                                 | \n | Name                                          |                      Now |      Default         Min         Max | \n |                                               |                          |                                      | \n | Init:showAllParticleData                      |                      off |          off                         | \n | Init:showAllSettings                          |                      off |          off                         | \n | Init:showChangedParticleData                  |                       on |           on                         | \n | Init:showChangedResonanceData                 |                      off |          off                         | \n | Init:showChangedSettings                      |                       on |           on                         | \n | Init:showMultipartonInteractions              |                       on |           on                         | \n | Init:showOneParticleData                      |                        0 |            0           0             | \n | Init:showProcesses                            |                       on |           on                         | \n |                                                                                                                 | \n *-------  End PYTHIA Flag + Mode + Parm + Word + FVec + MVec + PVec + WVec Settings  -----------------------------* \n julia> parm(csets, \"Beams:eA\")\n7000.0\n\nNote that class methods are called with the object instance as first argument. In C++ the parm(...) method of the Settings class would be called as csets.parm(\"Beams:eA\") being csets an instance of Settings, while in Julia it is called as parm(csets, \"Beams:eA\"). Thanks to the Julia multi-dispatch we do not need to prefix the methods with the module name PYTHIA8.parm, even for very common function names such as list.\n\nAlso notice that the default printout of any wrapped object is of the form C++/Julia type(at some address @0xXXXXXX) like this one: CxxRef{Pythia8!Settings}(Ptr{Pythia8!Settings} @0x00000001200d02d0). In this particular example, the C++ type is a reference to Pythia8::Settings and the object is at the memory address 0x00000001200d02d0.","category":"section"},{"location":"#Examples","page":"Introduction","title":"Examples","text":"Currently the following examples are implemented replicating the equivalent Python ones.","category":"section"},{"location":"#[main291.jl](https://github.com/JuliaHEP/PYTHIA8.jl/blob/main/examples/main291.jl)","page":"Introduction","title":"main291.jl","text":"Simple test program, equivalent to main101.cc, but written in Julia. It fits on one slide in a talk. It studies the charged multiplicity distribution at the LHC.","category":"section"},{"location":"#[main292.jl](https://github.com/JuliaHEP/PYTHIA8.jl/blob/main/examples/main292.jl)","page":"Introduction","title":"main292.jl","text":"Simple test program to illustrate the usage of PythiaParallel in Julia. The physics case is equivalent to main291, but in parallel.","category":"section"},{"location":"#[main293.jl](https://github.com/JuliaHEP/PYTHIA8.jl/blob/main/examples/main293.jl)","page":"Introduction","title":"main293.jl","text":"Example how you can use UserHooks to trace pT spectrum through the program, and veto undesirable jet multiplicities. It is based on main242.cc.","category":"section"},{"location":"#[main294.jl](https://github.com/JuliaHEP/PYTHIA8.jl/blob/main/examples/main294.jl)","page":"Introduction","title":"main294.jl","text":"Simple Julia script which reads and parses the Pythia 8 particle database (XML format), without requiring the Pythia8 Julia bindings.","category":"section"},{"location":"#[main296.jl](https://github.com/JuliaHEP/PYTHIA8.jl/blob/main/examples/main296.jl)","page":"Introduction","title":"main296.jl","text":"Example of how PYTHIA can be used as a shared library from Julia. The physics case is a study of total cross sections, which are not exposed currently cannot through the normal Julia interface.","category":"section"},{"location":"#Tests","page":"Introduction","title":"Tests","text":"Unit tests can be run with julia --project=. test/runtests.jl. It runs in addition all the implemented examples to ensure their correct execution and detection of any regression.","category":"section"},{"location":"#Re-generating-wrapper-code","page":"Introduction","title":"Re-generating wrapper code","text":"It is possible to re-generate the wrapper library locally instead of using the registered Pythia8_cxxwrap_jll package. This can be useful for adding new classes or functions to the wrapper library. These are the instructions:\n\nThe configuration file gen/Pythia8.wit.in is the input to the automated process. New header files can be added to the input list.\nThe script gen/build.jl does the work of generating the code and building the library. The command to execute are:\njulia --project=gen -e 'import Pkg; Pkg.instantiate()'\njulia --project=gen gen/build.jl","category":"section"},{"location":"tutorial/#PYTHIA8.jl-Tutorial","page":"Tutorial","title":"PYTHIA8.jl Tutorial","text":"This turorial demostrates a simple application of PYTHIA8.jl to generate some events and present the results in form of histograms. Please refer to the PYTHIA documentation for more details on the parameters and the physics processes.\n\nnote: Note that\nYou can also download this tutorial as a Jupyter notebook and a plain Julia source file.","category":"section"},{"location":"tutorial/#Table-of-contents","page":"Tutorial","title":"Table of contents","text":"Pages = [\"tutorial.md\"]\nDepth = 2:3","category":"section"},{"location":"tutorial/#Generate-events-and-plot-the-charged-multiplicity-distribution","page":"Tutorial","title":"Generate events and plot the charged multiplicity distribution","text":"In this example, we will generate 200 events at a center of mass energy of 8000 GeV and plot the charged multiplicity distribution.","category":"section"},{"location":"tutorial/#Loading-the-necessary-modules","page":"Tutorial","title":"Loading the necessary modules","text":"We will use the PYTHIA8 module to run the event generation.\nWe will use the FHist module to create the histograms.\nWe will use the Plots module to plot them.\n\nIf these modules are not installed, you can install them by running the following commands:\n\nusing Pkg\nPkg.add(\"PYTHIA8\")\nPkg.add(\"FHist\")\nPkg.add(\"Plots\")\n\nusing PYTHIA8\nusing FHist\nusing Plots: plot, plot!, theme\nimport DisplayAs: PNG #hide\n\nDefine the theme for the plots. See available themes and attributes in Plots.jl.\n\ntheme(:wong2, frame=:box, grid=false, minorticks=true,\n      guidefontvalign=:top, guidefonthalign=:right,\n      xlims=(:auto, :auto), lw=1.2, lab=\"\", colorbar=false)","category":"section"},{"location":"tutorial/#Initialize-PYTHIA","page":"Tutorial","title":"Initialize PYTHIA","text":"We will initialize PYTHIA with the following settings:\n\nCenter of mass energy of the collision: 8000 GeV\nAll hard QCD processes are enabled\nMinimum transverse momentum of the hard process: 20 GeV\n\nWe use the operator << to set the parameters and the operator |> to pipe to the init function. This added interface is quite ergonomic, however alternatively, we can use the functions directly provided by C++ interface, e.g.,\n\nreadString(pythia, \"Beams:eCM = 8000.\") or\nparm( settings(pythia), \"Beams:eCM\", 8000.)\n\npythia = PYTHIA8.Pythia(\"\", false);\npythia << \"Beams:eCM = 8000.\" <<\n          \"HardQCD:all = on\" <<\n          \"PhaseSpace:pTHatMin = 20.\";\nnothing #hide\n\nThe purpose of the next two lines is to reduce the amount of output during the event generation\n\npythia << \"Next:numberShowEvent = 0\" <<\n          \"Next:numberShowProcess = 0\";\nnothing #hide\n\nInitialize the event generation. The init function returns a boolean value. Alternatively, we can use the direct call to init(pythia) function.\n\npythia |> init;\nnothing #hide","category":"section"},{"location":"tutorial/#Create-a-1D-histogram","page":"Tutorial","title":"Create a 1D histogram","text":"We will create a histogram to store the charged multiplicity distribution. The histogram is defined with 25 bins ranging from -0.5 to 499.5. Note that with ranges we need to specify the number of edges (26) and not the number of bins (25)\n\nmult = Hist1D(binedges=range(-0.5, 499.5, 26));\nnothing #hide","category":"section"},{"location":"tutorial/#Generate-events","page":"Tutorial","title":"Generate events","text":"We will generate 200 events and fill the histogram with the number of charged particles making use of the count function. We use the push! function to fill the histogram.\n\nfor iEvent in 1:200\n    pythia |> next || continue\n    # Find number of all final charged particles and fill histogram.\n    nCharged = count(p -> isFinal(p) && isCharged(p), pythia |> event)\n    push!(mult, nCharged)\nend","category":"section"},{"location":"tutorial/#Print-the-statistics-and-plot-charged-multiplicity-distribution","page":"Tutorial","title":"Print the statistics and plot charged multiplicity distribution","text":"Print the generation statistics using the stat function from PYTHIA.\n\npythia |> PYTHIA8.stat\n\nPlot the histogram with the plot function from Plots.jl. We use the stepbins seriestype to plot the histogram as a step plot.\n\nimg = plot(mult, xlabel=\"counts\", ylabel=\"#particles\",\n           title=\"Charged Multiplicity Distribution\", seriestype=:stepbins,\n           c=2, lc=1, fill=0);\ndisplay(img)\nPNG(img) #hide","category":"section"},{"location":"tutorial/#Multi-threaded-version-of-the-same-example","page":"Tutorial","title":"Multi-threaded version of the same example","text":"In this example we repeat the same example as before but using multi-threading to generate the events faster.","category":"section"},{"location":"tutorial/#Initialize-Parallel-PYTHIA","page":"Tutorial","title":"Initialize Parallel PYTHIA","text":"Create an instance of PythiaParallel with the same settings as before. The PythiaParallel class is used to generate events concurrently using multiple threads. The settings are copied for each Pythia instance.\n\npythia_mt = PYTHIA8.PythiaParallel(\"\", false);\nnothing #hide\n\nPythiaParallel reads settings the same way as the normal Pythia does.\n\npythia_mt << \"Beams:eCM = 8000.\" <<\n             \"HardQCD:all = on\" <<\n             \"PhaseSpace:pTHatMin = 20.\";\nnothing #hide\n\nThe maximum degree of parallelism. If set to 0 (default), the program will use the maximum number of threads supported by the hardware.\n\npythia_mt << \"Parallelism:numThreads = 4\";\nnothing #hide\n\nThis defines the number of events generated by PythiaParallel::run.\n\npythia_mt << \"Main:numberOfEvents = 200\";\nnothing #hide\n\nThe next is a user provided function to initialize each underlying Pythia instance (one per thread). Please note that the function is called concurrently, therefore the use needs to avoid calling thread-unsafe functions. This is the reason we use the Core.println function instead of println.\n\nfunction w_init(pythia)::CxxBool\n    Core.println(\"Initializing Pythia with index $(mode(pythia |> settings, \"Parallelism:index\")).\")\n    return pythia |> init\nend;\nnothing #hide\n\nInitialize the event generation. The init function returns a boolean value to indicate the success. The user provided function w_init is called for each thread.\n\ninit(pythia_mt, w_init);\nnothing #hide","category":"section"},{"location":"tutorial/#Create-a-1D-histogram-2","page":"Tutorial","title":"Create a 1D histogram","text":"mult_mt = Hist1D(binedges=range(-0.5, 499.5, 26));\nnothing #hide","category":"section"},{"location":"tutorial/#Generate-events-2","page":"Tutorial","title":"Generate events","text":"Define a user function that will be called for each generated event. This function will be called concurrently by the threads. Therefore, we need to use thread-safe functions. Filling the histogram with atomic_push is thread-safe. The function takes a Pythia object as the first argument and returns Nothing.\n\nfunction analyze(pythiaNow)::Nothing\n    nCharged = count(p -> isFinal(p) && isCharged(p), pythiaNow |> event)\n    atomic_push!(mult_mt, nCharged)\n    return\nend\n\nRun the event generation. The number of events has been set in the Main:numberOfEvents parameter.\n\nPYTHIA8.run(pythia_mt, analyze);\nnothing #hide","category":"section"},{"location":"tutorial/#Print-the-statistics-and-plot-charged-multiplicity-distribution-2","page":"Tutorial","title":"Print the statistics and plot charged multiplicity distribution","text":"Print the statistics using the stat function from PYTHIA8.jl\n\npythia_mt |> PYTHIA8.stat\n\nPlot the result histogram\n\nimg = plot(mult_mt, xlabel=\"counts\", ylabel=\"#particles\",\n           title=\"Charged Multiplicity Distribution (multi-threaded)\", seriestype=:stepbins,\n           c=2, lc=1, fill=0);\ndisplay(img)\nPNG(img) #hide","category":"section"},{"location":"tutorial/#Speed-comparison-between-the-two-versions","page":"Tutorial","title":"Speed comparison between the two versions","text":"We will generate 1000 events and compare the time taken by the two versions.\n\nempty!(mult);\nempty!(mult_mt);\nnothing #hide","category":"section"},{"location":"tutorial/#Single-threaded-version","page":"Tutorial","title":"Single-threaded version","text":"Generate 1000 events and measure the time taken. This is done using the @elapsed macro.\n\nst_elap = @elapsed begin\n    for iEvent in 1:1000\n        pythia |> next || continue\n        nCharged = count(p -> isFinal(p) && isCharged(p), pythia |> event)\n        atomic_push!(mult, nCharged)\n    end\nend","category":"section"},{"location":"tutorial/#Multi-threaded-version","page":"Tutorial","title":"Multi-threaded version","text":"Generate 1000 events and measure the time taken. This is done using the @elapsed macro.\n\npythia_mt << \"Main:numberOfEvents = 1000\"\nmt_elap = @elapsed begin\n    PYTHIA8.run(pythia_mt, analyze)\nend\n\nPrint the speedup factor (4 threads)\n\nprintln(\"Speedup is $(st_elap/mt_elap).\")","category":"section"},{"location":"tutorial/#Make-a-plot-of-the-speedup-factor","page":"Tutorial","title":"Make a plot of the speedup factor","text":"We will generate events using 1, 2, 4, 8, 16, and 32 threads and plot the speedup factor. The speedup factor is defined as the ratio of the time taken by the single-threaded version to the time taken by the multi-threaded version.\n\nn_threads = [2^n for n in 0:5]\nspeedup = Float64[]\nw_init(pythiaNow)::CxxBool = pythiaNow |> init\nfor n_thread in n_threads\n    empty!(mult_mt)\n    _pythia = PYTHIA8.PythiaParallel(\"\", false);\n    _pythia << \"Beams:eCM = 8000.\" <<\n               \"HardQCD:all = on\" <<\n               \"PhaseSpace:pTHatMin = 20.\" <<\n               \"Parallelism:numThreads = $n_thread\" <<\n               \"Main:numberOfEvents = 1000\"\n    init(_pythia, w_init)\n\n    elap = @elapsed begin\n        PYTHIA8.run(_pythia, analyze)\n    end\n    push!(speedup, st_elap/elap)\nend;\nnothing #hide\n\nPlot the speedup factor vs the number of threads and overlay the line for the ideal scaling.\n\nimg = plot(n_threads, speedup, xlabel=\"#threads\", ylabel=\"speedup\",\n           title=\"Speedup vs #threads (#cores = $(Sys.CPU_THREADS))\",\n           seriestype=:scatter, legend=false,\n           xscale=:log10, yscale=:log10);\nnothing #hide\n\nAdd a line to the same plot\n\nplot!(n_threads, n_threads, seriestype=:line)\ndisplay(img)\nPNG(img) #hide\n\nnote: Note that\nThe plot is generated in a CI node using the cores available in the node. The speedup factor may not scale as expected.\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
